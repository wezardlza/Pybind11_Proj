#include <pybind11/pybind11.h>
#include <string>

namespace py = pybind11;

struct Pet {

public:
	// Constructor
	Pet(const std::string &name, const std::string &nick_name = "Sweet") : name(name), nick_name(nick_name) {  }
	Pet() : Pet("My pet", "Sweet") {  }
	virtual ~Pet() = default;

	// Set the name of a pet
	void setName(const std::string &name_) { name = name_; }
	// Get the name of a pet
	const std::string &getName() const { return name; }

	// Set the nick name of a pet
	void setNickName(const std::string &name_) { nick_name = name_; }
	// Get the nick name of a pet
	const std::string &getNickName() const { return nick_name; }

	// The name of the pet
	std::string name;

protected:
	// The nick name of the pet
	std::string nick_name;

};

struct Dog : Pet {
	Dog(const std::string &name) : Pet(name) {  }
	std::string bark() const { return "woof!"; }
};

// 'm' represent the module
PYBIND11_MODULE(example_class, m) {
	
	// The module explanations
	m.doc() = 
		"This module comes from the manual of the pybind11 library. More details can be obtained \
		from:\n\thttps://media.readthedocs.org/pdf/pybind11/master/pybind11.pdf"

	m.def("pet_store", []() { return std::unique_ptr<Pet>(new Dog);});

	/* -----------------------------------------------------------------------------------------------------------------
	'py::dynamic_attr()' is added as below so that we can add additional dynamic attributes in native Python rather than 
		define them in this CPP-to-Python extension project. Note that adding 'py::dynamic_attr()' causes efficiency
		penalties. Thus, the related class stored in .pyd generated by this project has equivalent efficiency to the 
		the native Python class. If py::dynamic_attr() must be enabled, the user should possibly use Python rather than
		CPP for the programming work.
	------------------------------------------------------------------------------------------------------------------*/
	py::class_<Pet>(m, "Pet", py::dynamic_attr())
	// OR --------------------------------------------------------------------------------------------------------------
	// py::class_<Pet> pet(m, "Pet")							
	/*----------------------------------------------------------------------------------------------------------------*/
		// Constructor
		.def(py::init<const std::string &, const std::string &>())
		.def(py::init<const std::string &>())
		.def(py::init<>())

		// Methods related to the name of a pet
		.def_readwrite("name", &Pet::name)
		.def("setName", &Pet::setName)
		.def("getName", &Pet::getName)

		// Methods related to the nick name of a pet
		.def_property("nick_name", &Pet::getNickName, &Pet::setNickName)
		.def("setNickName", &Pet::setNickName)
		.def("getNickName", &Pet::getNickName)
		
		// The default represnetation format of the example calss called Pet
		.def("__repr__",
			[](const Pet &a) {
				return "<example_class.Pet named '" + a.name + "'>";
			}
		);

	/* -----------------------------------------------------------------------------------------------------------------
	Two alternative methods for the definition of the hierarchical relationship.
	------------------------------------------------------------------------------------------------------------------*/
	// py::class_<Dog, Pet /* <- specify C++ parent type */>(m, "Dog")	
	//	.def(py::init<const std::string &>())							
	//	.def("bark", &Dog::bark);										
	// OR --------------------------------------------------------------------------------------------------------------
	py::class_<Dog>(m, "Dog", pet /* <- specify Python parent type */)	
		.def(py::init<const std::string &>())							
		.def("bark", &Dog::bark);										
	/*----------------------------------------------------------------------------------------------------------------*/

}
